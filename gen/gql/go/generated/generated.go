// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/graphikDB/graphik/gen/gql/go/model"
	"github.com/graphikDB/graphik/gql/scalars"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"google.golang.org/protobuf/types/known/emptypb"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthTarget struct {
		Headers func(childComplexity int) int
		Peer    func(childComplexity int) int
		Target  func(childComplexity int) int
		User    func(childComplexity int) int
	}

	Authorizer struct {
		Expression      func(childComplexity int) int
		Method          func(childComplexity int) int
		Name            func(childComplexity int) int
		TargetRequests  func(childComplexity int) int
		TargetResponses func(childComplexity int) int
	}

	Authorizers struct {
		Authorizers func(childComplexity int) int
	}

	Connection struct {
		Attributes func(childComplexity int) int
		Directed   func(childComplexity int) int
		From       func(childComplexity int) int
		Ref        func(childComplexity int) int
		To         func(childComplexity int) int
	}

	Connections struct {
		Connections func(childComplexity int) int
		SeekNext    func(childComplexity int) int
	}

	Doc struct {
		Attributes func(childComplexity int) int
		Ref        func(childComplexity int) int
	}

	Docs struct {
		Docs     func(childComplexity int) int
		SeekNext func(childComplexity int) int
	}

	Index struct {
		Expression        func(childComplexity int) int
		Gtype             func(childComplexity int) int
		Name              func(childComplexity int) int
		TargetConnections func(childComplexity int) int
		TargetDocs        func(childComplexity int) int
	}

	Indexes struct {
		Indexes func(childComplexity int) int
	}

	Message struct {
		Channel   func(childComplexity int) int
		Data      func(childComplexity int) int
		Method    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	Mutation struct {
		Broadcast          func(childComplexity int, input model.OutboundMessage) int
		CreateConnection   func(childComplexity int, input model.ConnectionConstructor) int
		CreateConnections  func(childComplexity int, input model.ConnectionConstructors) int
		CreateDoc          func(childComplexity int, input model.DocConstructor) int
		CreateDocs         func(childComplexity int, input model.DocConstructors) int
		DelConnection      func(childComplexity int, input model.RefInput) int
		DelConnections     func(childComplexity int, input model.Filter) int
		DelDoc             func(childComplexity int, input model.RefInput) int
		DelDocs            func(childComplexity int, input model.Filter) int
		EditConnection     func(childComplexity int, input model.Edit) int
		EditConnections    func(childComplexity int, input model.EditFilter) int
		EditDoc            func(childComplexity int, input model.Edit) int
		EditDocs           func(childComplexity int, input model.EditFilter) int
		SearchAndConnect   func(childComplexity int, input model.SearchConnectFilter) int
		SearchAndConnectMe func(childComplexity int, input model.SearchConnectMeFilter) int
		SetAuthorizers     func(childComplexity int, input model.AuthorizersInput) int
		SetIndexes         func(childComplexity int, input model.IndexesInput) int
		SetTriggers        func(childComplexity int, input model.TriggersInput) int
		SetTypeValidators  func(childComplexity int, input model.TypeValidatorsInput) int
	}

	Peer struct {
		Addr   func(childComplexity int) int
		NodeID func(childComplexity int) int
	}

	Query struct {
		AggregateConnections func(childComplexity int, where model.AggFilter) int
		AggregateDocs        func(childComplexity int, where model.AggFilter) int
		ConnectionsFrom      func(childComplexity int, where model.ConnectFilter) int
		ConnectionsTo        func(childComplexity int, where model.ConnectFilter) int
		ExistsConnection     func(childComplexity int, where model.ExistsFilter) int
		ExistsDoc            func(childComplexity int, where model.ExistsFilter) int
		GetConnection        func(childComplexity int, where model.RefInput) int
		GetDoc               func(childComplexity int, where model.RefInput) int
		GetSchema            func(childComplexity int, where *emptypb.Empty) int
		HasConnection        func(childComplexity int, where model.RefInput) int
		HasDoc               func(childComplexity int, where model.RefInput) int
		Me                   func(childComplexity int, where *emptypb.Empty) int
		SearchConnections    func(childComplexity int, where model.Filter) int
		SearchDocs           func(childComplexity int, where model.Filter) int
		Traverse             func(childComplexity int, where model.TraverseFilter) int
		TraverseMe           func(childComplexity int, where model.TraverseMeFilter) int
	}

	RaftState struct {
		Leader     func(childComplexity int) int
		Membership func(childComplexity int) int
		Peers      func(childComplexity int) int
		Stats      func(childComplexity int) int
	}

	Ref struct {
		Gid   func(childComplexity int) int
		Gtype func(childComplexity int) int
	}

	Refs struct {
		Refs func(childComplexity int) int
	}

	Schema struct {
		Authorizers     func(childComplexity int) int
		ConnectionTypes func(childComplexity int) int
		DocTypes        func(childComplexity int) int
		Indexes         func(childComplexity int) int
		Triggers        func(childComplexity int) int
		Validators      func(childComplexity int) int
	}

	Subscription struct {
		Stream func(childComplexity int, where model.StreamFilter) int
	}

	Traversal struct {
		Depth         func(childComplexity int) int
		Doc           func(childComplexity int) int
		Hops          func(childComplexity int) int
		TraversalPath func(childComplexity int) int
	}

	Traversals struct {
		Traversals func(childComplexity int) int
	}

	Trigger struct {
		Expression        func(childComplexity int) int
		Gtype             func(childComplexity int) int
		Name              func(childComplexity int) int
		TargetConnections func(childComplexity int) int
		TargetDocs        func(childComplexity int) int
		Trigger           func(childComplexity int) int
	}

	Triggers struct {
		Triggers func(childComplexity int) int
	}

	TypeValidator struct {
		Expression        func(childComplexity int) int
		Gtype             func(childComplexity int) int
		Name              func(childComplexity int) int
		TargetConnections func(childComplexity int) int
		TargetDocs        func(childComplexity int) int
	}

	TypeValidators struct {
		Validators func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateDoc(ctx context.Context, input model.DocConstructor) (*model.Doc, error)
	CreateDocs(ctx context.Context, input model.DocConstructors) (*model.Docs, error)
	EditDoc(ctx context.Context, input model.Edit) (*model.Doc, error)
	EditDocs(ctx context.Context, input model.EditFilter) (*model.Docs, error)
	DelDoc(ctx context.Context, input model.RefInput) (*emptypb.Empty, error)
	DelDocs(ctx context.Context, input model.Filter) (*emptypb.Empty, error)
	CreateConnection(ctx context.Context, input model.ConnectionConstructor) (*model.Connection, error)
	CreateConnections(ctx context.Context, input model.ConnectionConstructors) (*model.Connections, error)
	EditConnection(ctx context.Context, input model.Edit) (*model.Connection, error)
	EditConnections(ctx context.Context, input model.EditFilter) (*model.Connections, error)
	DelConnection(ctx context.Context, input model.RefInput) (*emptypb.Empty, error)
	DelConnections(ctx context.Context, input model.Filter) (*emptypb.Empty, error)
	Broadcast(ctx context.Context, input model.OutboundMessage) (*emptypb.Empty, error)
	SetIndexes(ctx context.Context, input model.IndexesInput) (*emptypb.Empty, error)
	SetAuthorizers(ctx context.Context, input model.AuthorizersInput) (*emptypb.Empty, error)
	SetTypeValidators(ctx context.Context, input model.TypeValidatorsInput) (*emptypb.Empty, error)
	SetTriggers(ctx context.Context, input model.TriggersInput) (*emptypb.Empty, error)
	SearchAndConnect(ctx context.Context, input model.SearchConnectFilter) (*model.Connections, error)
	SearchAndConnectMe(ctx context.Context, input model.SearchConnectMeFilter) (*model.Connections, error)
}
type QueryResolver interface {
	GetSchema(ctx context.Context, where *emptypb.Empty) (*model.Schema, error)
	Me(ctx context.Context, where *emptypb.Empty) (*model.Doc, error)
	GetDoc(ctx context.Context, where model.RefInput) (*model.Doc, error)
	SearchDocs(ctx context.Context, where model.Filter) (*model.Docs, error)
	Traverse(ctx context.Context, where model.TraverseFilter) (*model.Traversals, error)
	TraverseMe(ctx context.Context, where model.TraverseMeFilter) (*model.Traversals, error)
	GetConnection(ctx context.Context, where model.RefInput) (*model.Connection, error)
	ExistsDoc(ctx context.Context, where model.ExistsFilter) (bool, error)
	ExistsConnection(ctx context.Context, where model.ExistsFilter) (bool, error)
	HasDoc(ctx context.Context, where model.RefInput) (bool, error)
	HasConnection(ctx context.Context, where model.RefInput) (bool, error)
	SearchConnections(ctx context.Context, where model.Filter) (*model.Connections, error)
	ConnectionsFrom(ctx context.Context, where model.ConnectFilter) (*model.Connections, error)
	ConnectionsTo(ctx context.Context, where model.ConnectFilter) (*model.Connections, error)
	AggregateDocs(ctx context.Context, where model.AggFilter) (float64, error)
	AggregateConnections(ctx context.Context, where model.AggFilter) (float64, error)
}
type SubscriptionResolver interface {
	Stream(ctx context.Context, where model.StreamFilter) (<-chan *model.Message, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AuthTarget.headers":
		if e.complexity.AuthTarget.Headers == nil {
			break
		}

		return e.complexity.AuthTarget.Headers(childComplexity), true

	case "AuthTarget.peer":
		if e.complexity.AuthTarget.Peer == nil {
			break
		}

		return e.complexity.AuthTarget.Peer(childComplexity), true

	case "AuthTarget.target":
		if e.complexity.AuthTarget.Target == nil {
			break
		}

		return e.complexity.AuthTarget.Target(childComplexity), true

	case "AuthTarget.user":
		if e.complexity.AuthTarget.User == nil {
			break
		}

		return e.complexity.AuthTarget.User(childComplexity), true

	case "Authorizer.expression":
		if e.complexity.Authorizer.Expression == nil {
			break
		}

		return e.complexity.Authorizer.Expression(childComplexity), true

	case "Authorizer.method":
		if e.complexity.Authorizer.Method == nil {
			break
		}

		return e.complexity.Authorizer.Method(childComplexity), true

	case "Authorizer.name":
		if e.complexity.Authorizer.Name == nil {
			break
		}

		return e.complexity.Authorizer.Name(childComplexity), true

	case "Authorizer.target_requests":
		if e.complexity.Authorizer.TargetRequests == nil {
			break
		}

		return e.complexity.Authorizer.TargetRequests(childComplexity), true

	case "Authorizer.target_responses":
		if e.complexity.Authorizer.TargetResponses == nil {
			break
		}

		return e.complexity.Authorizer.TargetResponses(childComplexity), true

	case "Authorizers.authorizers":
		if e.complexity.Authorizers.Authorizers == nil {
			break
		}

		return e.complexity.Authorizers.Authorizers(childComplexity), true

	case "Connection.attributes":
		if e.complexity.Connection.Attributes == nil {
			break
		}

		return e.complexity.Connection.Attributes(childComplexity), true

	case "Connection.directed":
		if e.complexity.Connection.Directed == nil {
			break
		}

		return e.complexity.Connection.Directed(childComplexity), true

	case "Connection.from":
		if e.complexity.Connection.From == nil {
			break
		}

		return e.complexity.Connection.From(childComplexity), true

	case "Connection.ref":
		if e.complexity.Connection.Ref == nil {
			break
		}

		return e.complexity.Connection.Ref(childComplexity), true

	case "Connection.to":
		if e.complexity.Connection.To == nil {
			break
		}

		return e.complexity.Connection.To(childComplexity), true

	case "Connections.connections":
		if e.complexity.Connections.Connections == nil {
			break
		}

		return e.complexity.Connections.Connections(childComplexity), true

	case "Connections.seek_next":
		if e.complexity.Connections.SeekNext == nil {
			break
		}

		return e.complexity.Connections.SeekNext(childComplexity), true

	case "Doc.attributes":
		if e.complexity.Doc.Attributes == nil {
			break
		}

		return e.complexity.Doc.Attributes(childComplexity), true

	case "Doc.ref":
		if e.complexity.Doc.Ref == nil {
			break
		}

		return e.complexity.Doc.Ref(childComplexity), true

	case "Docs.docs":
		if e.complexity.Docs.Docs == nil {
			break
		}

		return e.complexity.Docs.Docs(childComplexity), true

	case "Docs.seek_next":
		if e.complexity.Docs.SeekNext == nil {
			break
		}

		return e.complexity.Docs.SeekNext(childComplexity), true

	case "Index.expression":
		if e.complexity.Index.Expression == nil {
			break
		}

		return e.complexity.Index.Expression(childComplexity), true

	case "Index.gtype":
		if e.complexity.Index.Gtype == nil {
			break
		}

		return e.complexity.Index.Gtype(childComplexity), true

	case "Index.name":
		if e.complexity.Index.Name == nil {
			break
		}

		return e.complexity.Index.Name(childComplexity), true

	case "Index.target_connections":
		if e.complexity.Index.TargetConnections == nil {
			break
		}

		return e.complexity.Index.TargetConnections(childComplexity), true

	case "Index.target_docs":
		if e.complexity.Index.TargetDocs == nil {
			break
		}

		return e.complexity.Index.TargetDocs(childComplexity), true

	case "Indexes.indexes":
		if e.complexity.Indexes.Indexes == nil {
			break
		}

		return e.complexity.Indexes.Indexes(childComplexity), true

	case "Message.channel":
		if e.complexity.Message.Channel == nil {
			break
		}

		return e.complexity.Message.Channel(childComplexity), true

	case "Message.data":
		if e.complexity.Message.Data == nil {
			break
		}

		return e.complexity.Message.Data(childComplexity), true

	case "Message.method":
		if e.complexity.Message.Method == nil {
			break
		}

		return e.complexity.Message.Method(childComplexity), true

	case "Message.timestamp":
		if e.complexity.Message.Timestamp == nil {
			break
		}

		return e.complexity.Message.Timestamp(childComplexity), true

	case "Message.user":
		if e.complexity.Message.User == nil {
			break
		}

		return e.complexity.Message.User(childComplexity), true

	case "Mutation.broadcast":
		if e.complexity.Mutation.Broadcast == nil {
			break
		}

		args, err := ec.field_Mutation_broadcast_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Broadcast(childComplexity, args["input"].(model.OutboundMessage)), true

	case "Mutation.createConnection":
		if e.complexity.Mutation.CreateConnection == nil {
			break
		}

		args, err := ec.field_Mutation_createConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateConnection(childComplexity, args["input"].(model.ConnectionConstructor)), true

	case "Mutation.createConnections":
		if e.complexity.Mutation.CreateConnections == nil {
			break
		}

		args, err := ec.field_Mutation_createConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateConnections(childComplexity, args["input"].(model.ConnectionConstructors)), true

	case "Mutation.createDoc":
		if e.complexity.Mutation.CreateDoc == nil {
			break
		}

		args, err := ec.field_Mutation_createDoc_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDoc(childComplexity, args["input"].(model.DocConstructor)), true

	case "Mutation.createDocs":
		if e.complexity.Mutation.CreateDocs == nil {
			break
		}

		args, err := ec.field_Mutation_createDocs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDocs(childComplexity, args["input"].(model.DocConstructors)), true

	case "Mutation.delConnection":
		if e.complexity.Mutation.DelConnection == nil {
			break
		}

		args, err := ec.field_Mutation_delConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelConnection(childComplexity, args["input"].(model.RefInput)), true

	case "Mutation.delConnections":
		if e.complexity.Mutation.DelConnections == nil {
			break
		}

		args, err := ec.field_Mutation_delConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelConnections(childComplexity, args["input"].(model.Filter)), true

	case "Mutation.delDoc":
		if e.complexity.Mutation.DelDoc == nil {
			break
		}

		args, err := ec.field_Mutation_delDoc_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelDoc(childComplexity, args["input"].(model.RefInput)), true

	case "Mutation.delDocs":
		if e.complexity.Mutation.DelDocs == nil {
			break
		}

		args, err := ec.field_Mutation_delDocs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelDocs(childComplexity, args["input"].(model.Filter)), true

	case "Mutation.editConnection":
		if e.complexity.Mutation.EditConnection == nil {
			break
		}

		args, err := ec.field_Mutation_editConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditConnection(childComplexity, args["input"].(model.Edit)), true

	case "Mutation.editConnections":
		if e.complexity.Mutation.EditConnections == nil {
			break
		}

		args, err := ec.field_Mutation_editConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditConnections(childComplexity, args["input"].(model.EditFilter)), true

	case "Mutation.editDoc":
		if e.complexity.Mutation.EditDoc == nil {
			break
		}

		args, err := ec.field_Mutation_editDoc_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditDoc(childComplexity, args["input"].(model.Edit)), true

	case "Mutation.editDocs":
		if e.complexity.Mutation.EditDocs == nil {
			break
		}

		args, err := ec.field_Mutation_editDocs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditDocs(childComplexity, args["input"].(model.EditFilter)), true

	case "Mutation.searchAndConnect":
		if e.complexity.Mutation.SearchAndConnect == nil {
			break
		}

		args, err := ec.field_Mutation_searchAndConnect_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SearchAndConnect(childComplexity, args["input"].(model.SearchConnectFilter)), true

	case "Mutation.searchAndConnectMe":
		if e.complexity.Mutation.SearchAndConnectMe == nil {
			break
		}

		args, err := ec.field_Mutation_searchAndConnectMe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SearchAndConnectMe(childComplexity, args["input"].(model.SearchConnectMeFilter)), true

	case "Mutation.setAuthorizers":
		if e.complexity.Mutation.SetAuthorizers == nil {
			break
		}

		args, err := ec.field_Mutation_setAuthorizers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetAuthorizers(childComplexity, args["input"].(model.AuthorizersInput)), true

	case "Mutation.setIndexes":
		if e.complexity.Mutation.SetIndexes == nil {
			break
		}

		args, err := ec.field_Mutation_setIndexes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetIndexes(childComplexity, args["input"].(model.IndexesInput)), true

	case "Mutation.setTriggers":
		if e.complexity.Mutation.SetTriggers == nil {
			break
		}

		args, err := ec.field_Mutation_setTriggers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTriggers(childComplexity, args["input"].(model.TriggersInput)), true

	case "Mutation.setTypeValidators":
		if e.complexity.Mutation.SetTypeValidators == nil {
			break
		}

		args, err := ec.field_Mutation_setTypeValidators_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTypeValidators(childComplexity, args["input"].(model.TypeValidatorsInput)), true

	case "Peer.addr":
		if e.complexity.Peer.Addr == nil {
			break
		}

		return e.complexity.Peer.Addr(childComplexity), true

	case "Peer.node_id":
		if e.complexity.Peer.NodeID == nil {
			break
		}

		return e.complexity.Peer.NodeID(childComplexity), true

	case "Query.aggregateConnections":
		if e.complexity.Query.AggregateConnections == nil {
			break
		}

		args, err := ec.field_Query_aggregateConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateConnections(childComplexity, args["where"].(model.AggFilter)), true

	case "Query.aggregateDocs":
		if e.complexity.Query.AggregateDocs == nil {
			break
		}

		args, err := ec.field_Query_aggregateDocs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AggregateDocs(childComplexity, args["where"].(model.AggFilter)), true

	case "Query.connectionsFrom":
		if e.complexity.Query.ConnectionsFrom == nil {
			break
		}

		args, err := ec.field_Query_connectionsFrom_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectionsFrom(childComplexity, args["where"].(model.ConnectFilter)), true

	case "Query.connectionsTo":
		if e.complexity.Query.ConnectionsTo == nil {
			break
		}

		args, err := ec.field_Query_connectionsTo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectionsTo(childComplexity, args["where"].(model.ConnectFilter)), true

	case "Query.existsConnection":
		if e.complexity.Query.ExistsConnection == nil {
			break
		}

		args, err := ec.field_Query_existsConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ExistsConnection(childComplexity, args["where"].(model.ExistsFilter)), true

	case "Query.existsDoc":
		if e.complexity.Query.ExistsDoc == nil {
			break
		}

		args, err := ec.field_Query_existsDoc_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ExistsDoc(childComplexity, args["where"].(model.ExistsFilter)), true

	case "Query.getConnection":
		if e.complexity.Query.GetConnection == nil {
			break
		}

		args, err := ec.field_Query_getConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetConnection(childComplexity, args["where"].(model.RefInput)), true

	case "Query.getDoc":
		if e.complexity.Query.GetDoc == nil {
			break
		}

		args, err := ec.field_Query_getDoc_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDoc(childComplexity, args["where"].(model.RefInput)), true

	case "Query.getSchema":
		if e.complexity.Query.GetSchema == nil {
			break
		}

		args, err := ec.field_Query_getSchema_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSchema(childComplexity, args["where"].(*emptypb.Empty)), true

	case "Query.hasConnection":
		if e.complexity.Query.HasConnection == nil {
			break
		}

		args, err := ec.field_Query_hasConnection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasConnection(childComplexity, args["where"].(model.RefInput)), true

	case "Query.hasDoc":
		if e.complexity.Query.HasDoc == nil {
			break
		}

		args, err := ec.field_Query_hasDoc_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasDoc(childComplexity, args["where"].(model.RefInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		args, err := ec.field_Query_me_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Me(childComplexity, args["where"].(*emptypb.Empty)), true

	case "Query.searchConnections":
		if e.complexity.Query.SearchConnections == nil {
			break
		}

		args, err := ec.field_Query_searchConnections_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchConnections(childComplexity, args["where"].(model.Filter)), true

	case "Query.searchDocs":
		if e.complexity.Query.SearchDocs == nil {
			break
		}

		args, err := ec.field_Query_searchDocs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchDocs(childComplexity, args["where"].(model.Filter)), true

	case "Query.traverse":
		if e.complexity.Query.Traverse == nil {
			break
		}

		args, err := ec.field_Query_traverse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Traverse(childComplexity, args["where"].(model.TraverseFilter)), true

	case "Query.traverseMe":
		if e.complexity.Query.TraverseMe == nil {
			break
		}

		args, err := ec.field_Query_traverseMe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TraverseMe(childComplexity, args["where"].(model.TraverseMeFilter)), true

	case "RaftState.leader":
		if e.complexity.RaftState.Leader == nil {
			break
		}

		return e.complexity.RaftState.Leader(childComplexity), true

	case "RaftState.membership":
		if e.complexity.RaftState.Membership == nil {
			break
		}

		return e.complexity.RaftState.Membership(childComplexity), true

	case "RaftState.peers":
		if e.complexity.RaftState.Peers == nil {
			break
		}

		return e.complexity.RaftState.Peers(childComplexity), true

	case "RaftState.stats":
		if e.complexity.RaftState.Stats == nil {
			break
		}

		return e.complexity.RaftState.Stats(childComplexity), true

	case "Ref.gid":
		if e.complexity.Ref.Gid == nil {
			break
		}

		return e.complexity.Ref.Gid(childComplexity), true

	case "Ref.gtype":
		if e.complexity.Ref.Gtype == nil {
			break
		}

		return e.complexity.Ref.Gtype(childComplexity), true

	case "Refs.refs":
		if e.complexity.Refs.Refs == nil {
			break
		}

		return e.complexity.Refs.Refs(childComplexity), true

	case "Schema.authorizers":
		if e.complexity.Schema.Authorizers == nil {
			break
		}

		return e.complexity.Schema.Authorizers(childComplexity), true

	case "Schema.connection_types":
		if e.complexity.Schema.ConnectionTypes == nil {
			break
		}

		return e.complexity.Schema.ConnectionTypes(childComplexity), true

	case "Schema.doc_types":
		if e.complexity.Schema.DocTypes == nil {
			break
		}

		return e.complexity.Schema.DocTypes(childComplexity), true

	case "Schema.indexes":
		if e.complexity.Schema.Indexes == nil {
			break
		}

		return e.complexity.Schema.Indexes(childComplexity), true

	case "Schema.triggers":
		if e.complexity.Schema.Triggers == nil {
			break
		}

		return e.complexity.Schema.Triggers(childComplexity), true

	case "Schema.validators":
		if e.complexity.Schema.Validators == nil {
			break
		}

		return e.complexity.Schema.Validators(childComplexity), true

	case "Subscription.stream":
		if e.complexity.Subscription.Stream == nil {
			break
		}

		args, err := ec.field_Subscription_stream_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Stream(childComplexity, args["where"].(model.StreamFilter)), true

	case "Traversal.depth":
		if e.complexity.Traversal.Depth == nil {
			break
		}

		return e.complexity.Traversal.Depth(childComplexity), true

	case "Traversal.doc":
		if e.complexity.Traversal.Doc == nil {
			break
		}

		return e.complexity.Traversal.Doc(childComplexity), true

	case "Traversal.hops":
		if e.complexity.Traversal.Hops == nil {
			break
		}

		return e.complexity.Traversal.Hops(childComplexity), true

	case "Traversal.traversal_path":
		if e.complexity.Traversal.TraversalPath == nil {
			break
		}

		return e.complexity.Traversal.TraversalPath(childComplexity), true

	case "Traversals.traversals":
		if e.complexity.Traversals.Traversals == nil {
			break
		}

		return e.complexity.Traversals.Traversals(childComplexity), true

	case "Trigger.expression":
		if e.complexity.Trigger.Expression == nil {
			break
		}

		return e.complexity.Trigger.Expression(childComplexity), true

	case "Trigger.gtype":
		if e.complexity.Trigger.Gtype == nil {
			break
		}

		return e.complexity.Trigger.Gtype(childComplexity), true

	case "Trigger.name":
		if e.complexity.Trigger.Name == nil {
			break
		}

		return e.complexity.Trigger.Name(childComplexity), true

	case "Trigger.target_connections":
		if e.complexity.Trigger.TargetConnections == nil {
			break
		}

		return e.complexity.Trigger.TargetConnections(childComplexity), true

	case "Trigger.target_docs":
		if e.complexity.Trigger.TargetDocs == nil {
			break
		}

		return e.complexity.Trigger.TargetDocs(childComplexity), true

	case "Trigger.trigger":
		if e.complexity.Trigger.Trigger == nil {
			break
		}

		return e.complexity.Trigger.Trigger(childComplexity), true

	case "Triggers.triggers":
		if e.complexity.Triggers.Triggers == nil {
			break
		}

		return e.complexity.Triggers.Triggers(childComplexity), true

	case "TypeValidator.expression":
		if e.complexity.TypeValidator.Expression == nil {
			break
		}

		return e.complexity.TypeValidator.Expression(childComplexity), true

	case "TypeValidator.gtype":
		if e.complexity.TypeValidator.Gtype == nil {
			break
		}

		return e.complexity.TypeValidator.Gtype(childComplexity), true

	case "TypeValidator.name":
		if e.complexity.TypeValidator.Name == nil {
			break
		}

		return e.complexity.TypeValidator.Name(childComplexity), true

	case "TypeValidator.target_connections":
		if e.complexity.TypeValidator.TargetConnections == nil {
			break
		}

		return e.complexity.TypeValidator.TargetConnections(childComplexity), true

	case "TypeValidator.target_docs":
		if e.complexity.TypeValidator.TargetDocs == nil {
			break
		}

		return e.complexity.TypeValidator.TargetDocs(childComplexity), true

	case "TypeValidators.validators":
		if e.complexity.TypeValidators.Validators == nil {
			break
		}

		return e.complexity.TypeValidators.Validators(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next()

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "schema.graphql", Input: `# time is an rfc 3339 timestamp
scalar Time
# Map is a k/v map where the key is a string and the value is any value
scalar Map
# Empty is a container to represent no values
scalar Empty

# Algorithm is a Graph Traversal algorithm
enum Algorithm {
  # BFS is short for the breadth-first search algorithm
  BFS
  # DFS is short for the depth-first search algorithm
  DFS
}

enum Aggregate {
  # Count counts the number of elements in the group defined
  COUNT
  # SUM calculates the sum of the given attribute/expression in the group defined
  SUM
  # AVG calculates the average value of the given attribute/expression in the group defined
  AVG
  # MAX finds the maximum in the group defined
  MAX
  # MIN finds the minimum in the group defined
  MIN
  # PROD finds the product of all of the values in the group defined
  PROD
}

# Membership is the state of a raft membership in a cluster
enum Membership {
  UNKNOWN
  FOLLOWER
  CANDIDATE
  LEADER
  SHUTDOWN
}

# Ref describes a doc/connection type & id
type Ref {
  # gtype is the type of the doc/connection ex: pet
  gtype: String!
  # gid is the unique id of the doc/connection within the context of it's type
  gid: String!
}

# Doc is a Graph primitive representing a single entity/resource. It is connected to other docs via Connections
type Doc {
  # ref is the ref to the doc
  ref: Ref!
  # k/v pairs
  attributes: Map
}

# Docs is an array of docs
type Docs {
  # docs is an array of docs
  docs: [Doc!]
  # seek_next is the next value in the sequence (used for pagination)
  seek_next: String
}

# Traversal is a document found during a traversal & its relative path to the root node that searched for it
type Traversal {
  doc: Doc!
  traversal_path: [Ref!]
  depth: Int!
  hops: Int!
}

# AuthTarget
type AuthTarget {
  # user is the user making the request
  user: Doc!
  # target is the payload gived to the authorizer(request or response payload)
  target: Map!
  peer: String!
  headers: Map!
}

# Traversals is an array of Traversal that is returned from Graph traversal algorithms
type Traversals {
  # traversals is an array of Traversal
  traversals: [Traversal!]
}

# Refs is an array of Ref
type Refs {
  refs: [Ref!]
}

# TypeValidator a graph primitive used to validate custom doc/connection constraints
type TypeValidator {
  # name is the unique name of the type validator
  name: String!
  # gtype is the type of object the validator will be applied to (ex: user)
  gtype: String!
  # expression is a boolean CEL expression used to evaluate the doc/connection
  expression: String!
  # if target_docs is true, this validator will be applied to documents.
  target_docs: Boolean!
  # if target_connections is true, this validator will be applied to connections.
  target_connections: Boolean!
}

# TypeValidators is an array of TypeValidator
type TypeValidators {
  validators: [TypeValidator!]
}

type Trigger {
  # name is the unique name of the type validator
  name: String!
  # gtype is the type of object the validator will be applied to (ex: user)
  gtype: String!
  # expression is a boolean CEL expression used to evaluate the doc/connection
  expression: String!
  # trigger is the map CEL expression that mutates the doc/connection before it is stored
  trigger: String!
  # if target_docs is true, this validator will be applied to documents.
  target_docs: Boolean!
  # if target_connections is true, this validator will be applied to connections.
  target_connections: Boolean!
}

type Triggers {
  triggers: [Trigger!]
}

# Connection is a graph primitive that represents a relationship between two docs
type Connection {
  # ref is the ref to the connection
  ref: Ref!
  # k/v pairs
  attributes: Map
  # directed is false if the connection is bi-directional
  directed: Boolean!
  # from is the doc ref that is the source of the connection
  from: Ref!
  # to is the doc ref that is the destination of the connection
  to: Ref!
}

# Connections is an array of connections
type Connections {
  # connections is an array of connections
  connections: [Connection!]
  # seek_next is the next value in the sequence (used for pagination)
  seek_next: String
}

# Index is a graph primitive used for fast lookups of docs/connections that pass a boolean CEL expression
type Index {
  # name is the unique name of the index in the graph
  name: String!
  # gtype is the type of object the index will be applied to (ex: user)
  gtype: String!
  # expression is a boolean CEL expression used to evaluate the doc/connection
  expression: String!
  # if target_docs is true, this index will be applied to documents.
  target_docs: Boolean!
  # if target_connections is true, this index will be applied to connections.
  target_connections: Boolean!
}

# Indexes is an array of Index
type Indexes {
  indexes: [Index!]
}

# Peer is the address and id of a node in the raft cluster
type Peer {
  node_id: String!
  addr: String!
}

# RaftState returns information about the raft cluster
type RaftState {
  leader: String!
  membership: Membership!
  peers: [Peer!]
  stats: Map!
}

# Authorizer is a graph primitive used for authorizing inbound requests and/or responses(see AuthTarget)
type Authorizer {
  # name is the unique name of the authorizer in the graph
  name: String!
  # method is the rpc method that will invoke the authorizer
  method: String!
  # expression is the boolean CEL expression that evaluates either the request or response body
  expression: String!
  # target_responses sets the authorizer to evaluate request bodies of the target grpc method
  target_requests:   Boolean!
  # target_responses sets the authorizer to evaluate response bodies of the target grpc method
  target_responses: Boolean!
}

# Authorizers is an array of Authorizer
type Authorizers {
  authorizers: [Authorizer!]
}

# Schema returns registered connection & doc types & other graph primitives
type Schema {
  # connection_types are the types of connections in the graph
  connection_types: [String!]
  # doc_types are the types of docs in the graph
  doc_types: [String!]
  # authorizers are all of registered authorizers in the graph
  authorizers: Authorizers
  # validators are all of registered validators in the graph
  validators: TypeValidators
  # indexes are all of the registered indexes in the graph
  indexes: Indexes
  # triggers are all of the registered triggers in the graph
  triggers: Triggers
}

# Message is received on PubSub subscriptions
type Message {
  # channel is the channel the message was sent to
  channel: String!
  # data is the data sent with the message
  data: Map!
  # user is the user that sent/triggered the message
  user: Ref!
  # timestamp is when the message was sent
  timestamp: Time!
  # method is the gRPC method that invoked the message delivery
  method: String!
}

# RefConstructor is used to create a Ref
input RefConstructor {
  # gtype is the type of the doc/connection ex: pet
  gtype: String!
  # gid is the unique id of the doc/connection within the context of it's type. If none is provided, a k-sortable uuid will be assigned
  gid: String
}

# DocConstructor is used to create a Doc
input DocConstructor {
  # ref is the gtype/gid of the doc to create. If no gid is provided, a k-sortable uuid will be assigned
  ref: RefConstructor!
  # attributes are k/v pairs
  attributes: Map
}

# DocConstructors is an array of DocConstructor
input DocConstructors {
  docs: [DocConstructor!]!
}

# ConnectionConstructor is used to create an Connection
input ConnectionConstructor {
  # ref is the gtype/gid of the connection to create. If no gid is provided, a k-sortable uuid will be assigned
  ref: RefConstructor!
  # directed is false if the connection is bi-directional
  directed: Boolean!
  # attributes are k/v paris associated with the Connection to create
  attributes: Map
  # from is the doc ref that is the source of the connection
  from: RefInput!
  # to is the doc ref that is the destination of the connection
  to: RefInput!
}

# ConnectionConstructors is an array of ConnectionConstructor
input ConnectionConstructors {
  connections: [ConnectionConstructor!]!
}

# RefInput is the ref to a doc/connection
input RefInput {
  # ref is the ref to the target doc/connection to edit
  gtype: String!
  # ref is the ref to the target doc/connection to edit
  gid: String!
}

# PeerInput is the address and id of a node in the raft cluster
input PeerInput {
  node_id: String!
  addr: String!
}

# Filter is a generic filter using Common Expression Language
input Filter {
  # gtype is the doc/connection type to be filtered
  gtype: String!
  # expression is a CEL expression used to filter connections/nodes
  expression: String
  # limit is the maximum number of items to return
  limit: Int!
  # custom sorting of the results.
  sort: String
  # seek to a specific key for pagination
  seek: String
  # reverse the results
  reverse: Boolean
  # search in a specific index
  index: String
}

# SearchConnectFilter is used for searching for documents and adding connections based on whether they pass a Filter
input SearchConnectFilter {
  # filter is the filter to apply against the graph.
  filter: Filter!
  # gtype is the type of the connection to create
  gtype: String!
  # attributes are k/v pairs to associate with the new connection
  attributes: Map
  # directed indicates whether the connection is uni-directional(instagram) or bi-directional(facebook)
  directed: Boolean!
  # from indicates the root document of the connection to create
  from: RefInput!
}

# SearchConnectMeFilter is used for searching for documents and adding connections from the origin user to the document based on whether they pass a Filter
input SearchConnectMeFilter {
  # filter is the filter to apply against the graph.
  filter: Filter!
  # gtype is the type of the connection to create
  gtype: String!
  # attributes are k/v pairs to associate with the new connection
  attributes: Map
  # directed indicates whether the connection is uni-directional(instagram) or bi-directional(facebook)
  directed: Boolean!
}

# AggFilter is a filter used for aggragation queries
input AggFilter {
  # filter is the filter to apply against the graph.
  filter: Filter!
  # aggregate is the aggregation function to apply against the graph
  aggregate: Aggregate!
  # field is the field to aggregate(ex: attributes.age). The field must be a float/number value
  field: String
}

# TraverseFilter is a filter used for graph traversals
input TraverseFilter {
  # gtype is the doc/connection type to be filtered
  root: RefInput!
  # doc_expression is a boolean CEL expression used to determine which docs to traverse
  doc_expression: String
  # connection_expression is a boolean CEL expression used to determine which connections to traverse
  connection_expression: String
  # limit is the maximum number of items to return
  limit: Int!
  # custom sorting of the results.
  sort: String
  # reverse the direction of the connection traversal
  reverse: Boolean
  # DFS(depth-first-search) or BFS(breadth-first-search). Defaults to breadth-first
  algorithm: Algorithm
  # maximum degree/depth of nodes to be visited during traversal
  max_depth: Int!
  # maximum number of nodes to be visited during traversal
  max_hops: Int!
}

# TraverseMeFilter is a filter used for graph traversals of the origin user
input TraverseMeFilter {
  # doc_expression is a boolean CEL expression used to determine which docs to traverse
  doc_expression: String
  # connection_expression is a boolean CEL expression used to determine which connections to traverse
  connection_expression: String
  # limit is the maximum number of items to return
  limit: Int!
  # custom sorting of the results.
  sort: String
  # reverse the direction of the connection traversal
  reverse: Boolean
  # DFS(depth-first-search) or BFS(breadth-first-search). Defaults to breadth-first
  algorithm: Algorithm
  # maximum degree/depth of nodes to be visited during traversal
  max_depth: Int!
  # maximum number of nodes to be visited during traversal
  max_hops: Int!
}

# ConnectFilter is used to fetch connections related to a single noted
input ConnectFilter {
  # doc_ref is the ref to the target doc
  doc_ref: RefInput!
  # gtype is the type of connections to return
  gtype: String!
  # expression is a CEL expression used to filter connections
  expression: String,
  # limit is the maximum number of connections to return
  limit: Int!
  # custom sorting of the results.
  sort: String
  # seek to a specific key for pagination
  seek: String
  # reverse the results
  reverse: Boolean
}

# StreamFilter is used to filter messages in a pubsub channel
input StreamFilter {
  # channel is the target channel to listen on
  channel: String!
  # expression is a CEL expression used to filter messages
  expression: String
}

# Edit edites the attributes of a Doc or Connection
input Edit {
  # ref is the ref to the target doc/connection to edit
  ref: RefInput!
  # attributes are k/v pairs used to overwrite k/v pairs on a doc/connection
  attributes: Map!
}

# EditFilter is used to edit/patch docs/connections
input EditFilter {
  # filter is used to filter docs/connections to edit
  filter: Filter!
  # attributes are k/v pairs used to overwrite k/v pairs on a doc/connection
  attributes: Map!
}

# OutboundMessage is a message to be published to a pubsub channel
input OutboundMessage {
  # channel is the target channel to send the message to
  channel: String!
  # data is the data to send with the message
  data: Map!
}

# ExprFilter is a generic filter that uses a boolean CEL expression
input ExprFilter {
  # expression is a CEL expression used to filter messages/docs/connections
  expression: String
}

# IndexInput is used to construct Indexes
input IndexInput {
  # name is the unique name of the index in the graph
  name: String!
  # gtype is the type of object the validator will be applied to (ex: user)
  gtype: String!
  # expression is a boolean CEL expression used to evaluate the doc/connection
  expression: String!
  # if target_docs is true, this index will be applied to documents.
  target_docs: Boolean!
  # if target_connections is true, this index will be applied to connections.
  target_connections: Boolean!
}

# IndexesInput is an array IndexInput
input IndexesInput {
  indexes: [IndexInput!]
}


# TriggerInput is used to construct Trigger
input TriggerInput {
  # name is the unique name of the type validator
  name: String!
  # gtype is the type of object the validator will be applied to (ex: user)
  gtype: String!
  # expression is a boolean CEL expression used to evaluate the doc/connection
  expression: String!
  # trigger is the map CEL expression that mutates the doc/connection before it is stored
  trigger: String!
  # if target_docs is true, this validator will be applied to documents.
  target_docs: Boolean!
  # if target_connections is true, this validator will be applied to connections.
  target_connections: Boolean!
}

# TriggersInput is an array TriggerInput
input TriggersInput {
  triggers: [TriggerInput!]
}

# AuthorizerInput is used to create a new Authorizer
input AuthorizerInput {
  # name is the unique name of the authorizer in the graph
  name: String!
  # method is the rpc method that will invoke the authorizer
  method: String!
  # expression is the boolean CEL expression that evaluates either the request or response body
  expression: String!
  # target_responses sets the authorizer to evaluate request bodies of the target grpc method
  target_requests:   Boolean!
  # target_responses sets the authorizer to evaluate response bodies of the target grpc method
  target_responses: Boolean!
}

# AuthorizersInput is an array of authorizers
input AuthorizersInput {
  authorizers: [AuthorizerInput!]
}

# TypeValidatorInput is used to construct a new type validator
input TypeValidatorInput {
  # name is the unique name of the type validator
  name: String!
  # gtype is the type of object the validator will be applied to (ex: user)
  gtype: String!
  # expression is a boolean CEL expression used to evaluate the doc/connection
  expression: String!
  # if target_docs is true, this validator will be applied to documents.
  target_docs: Boolean!
  # if target_connections is true, this validator will be applied to connections.
  target_connections: Boolean!
}

# TypeValidatorsInput is an array of TypeValidatorInput
input TypeValidatorsInput {
  validators: [TypeValidatorInput!]
}

# Exists is a filter used to determine whether a doc/connection exists in the graph
input ExistsFilter {
  # gtype is the doc/connection type to be filtered
  gtype: String!
  # expression is a CEL expression used to filter connections/nodes
  expression: String!
  # seek to a specific key for pagination
  seek: String
  # reverse the results
  reverse: Boolean
  # search in a specific index
  index: String
}

type Mutation {
  # createDoc creates a single doc in the graph
  createDoc(input: DocConstructor!): Doc!
  # createDocs creates 1-many documents in the graph
  createDocs(input: DocConstructors!): Docs!
  # editDoc edites a single doc in the graph
  editDoc(input: Edit!): Doc!
  # editDocs edites 0-many docs in the graph
  editDocs(input: EditFilter!): Docs!
  # delDoc deletes a doc by reference
  delDoc(input: RefInput!): Empty
  # delDocs deletes 0-many docs that pass a Filter
  delDocs(input: Filter!): Empty
  # createConnection creates a single connection in the graph
  createConnection(input: ConnectionConstructor!): Connection!
  # createConnections creates 1-many connections in the graph
  createConnections(input: ConnectionConstructors!): Connections!
  # editConnection edites a single connection in the graph
  editConnection(input: Edit!): Connection!
  # editConnections edites 0-many connections in the graph
  editConnections(input: EditFilter!): Connections!
  # delConnection deletes a connection by reference
  delConnection(input: RefInput!): Empty
  # delConnections deletes 0-many connections that pass a Filter
  delConnections(input: Filter!): Empty
  # broadcast broadcasts a mesage to a pubsub/stream channel
  broadcast(input: OutboundMessage!): Empty
  # setIndexes sets all of the indexes in the graph
  setIndexes(input: IndexesInput!): Empty
  # setAuthorizers sets all of the authorizers in the graph
  setAuthorizers(input: AuthorizersInput!): Empty
  # setTypeValidators sets all of the type validators in the graph
  setTypeValidators(input: TypeValidatorsInput!): Empty
  # v sets all of the triggers in the graph
  setTriggers(input: TriggersInput!): Empty
  # searchAndConnect searches for documents and forms connections based on whether they pass a filter
  searchAndConnect(input: SearchConnectFilter!): Connections!
  # searchAndConnectMe searches for documents and forms connections from the origin user to the document based on whether they pass a filter
  searchAndConnectMe(input: SearchConnectMeFilter!): Connections!
}

type Query {
  # getSchema gets information about node/connection types, type-validators, indexes, and authorizers
  getSchema(where: Empty): Schema!
  # me returns a Doc of the currently logged in user
  me(where: Empty): Doc!
  # getDoc gets a doc at the given ref
  getDoc(where: RefInput!): Doc!
  # searchDocs searches for 0-many docs
  searchDocs(where: Filter!): Docs!
  # traverse searches for 0-many docs using a graph traversal algorithm
  traverse(where: TraverseFilter!): Traversals!
  # traverseMe searches for 0-many docs related to the origin user using a graph traversal algorithm
  traverseMe(where: TraverseMeFilter!): Traversals!
  # getConnection gets a connection at the given ref
  getConnection(where: RefInput!): Connection!
  # existsDoc checks if a document exists in the graph
  existsDoc(where: ExistsFilter!): Boolean!
  # existsConnection checks if a connection exists in the graph
  existsConnection(where: ExistsFilter!): Boolean!
  # hasDoc checks if a document exists in the graph by reference
  hasDoc(where: RefInput!): Boolean!
  # hasConnection checks if a connection exists in the graph by reference
  hasConnection(where: RefInput!): Boolean!
  # searchConnections searches for 0-many connections
  searchConnections(where: Filter!): Connections!
  # connectionsFrom returns connections from the given doc that pass the filter
  connectionsFrom(where: ConnectFilter!): Connections!
  # connectionsTo returns connections to the given doc that pass the filter
  connectionsTo(where: ConnectFilter!): Connections!
  # aggregateDocs executes an aggregation function against a set of documents
  aggregateDocs(where: AggFilter!): Float!
  # aggregateConnections executes an aggregation function against a set of connections
  aggregateConnections(where: AggFilter!): Float!
}

type Subscription {
  # stream opens a stream of messages that pass a filter on a pubsub channel. state changes are sent to the 'state' channel.
  stream(where: StreamFilter!): Message!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_broadcast_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.OutboundMessage
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNOutboundMessage2githubcomgraphikDBgraphikgengqlgomodelOutboundMessage(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ConnectionConstructor
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNConnectionConstructor2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ConnectionConstructors
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNConnectionConstructors2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructors(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDoc_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DocConstructor
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDocConstructor2githubcomgraphikDBgraphikgengqlgomodelDocConstructor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createDocs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DocConstructors
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDocConstructors2githubcomgraphikDBgraphikgengqlgomodelDocConstructors(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_delConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RefInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_delConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Filter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_delDoc_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RefInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_delDocs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Filter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_editConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Edit
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNEdit2githubcomgraphikDBgraphikgengqlgomodelEdit(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_editConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.EditFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNEditFilter2githubcomgraphikDBgraphikgengqlgomodelEditFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_editDoc_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Edit
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNEdit2githubcomgraphikDBgraphikgengqlgomodelEdit(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_editDocs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.EditFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNEditFilter2githubcomgraphikDBgraphikgengqlgomodelEditFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_searchAndConnectMe_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SearchConnectMeFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSearchConnectMeFilter2githubcomgraphikDBgraphikgengqlgomodelSearchConnectMeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_searchAndConnect_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.SearchConnectFilter
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNSearchConnectFilter2githubcomgraphikDBgraphikgengqlgomodelSearchConnectFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setAuthorizers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AuthorizersInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNAuthorizersInput2githubcomgraphikDBgraphikgengqlgomodelAuthorizersInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setIndexes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.IndexesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNIndexesInput2githubcomgraphikDBgraphikgengqlgomodelIndexesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setTriggers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TriggersInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNTriggersInput2githubcomgraphikDBgraphikgengqlgomodelTriggersInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setTypeValidators_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TypeValidatorsInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNTypeValidatorsInput2githubcomgraphikDBgraphikgengqlgomodelTypeValidatorsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_aggregateConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AggFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNAggFilter2githubcomgraphikDBgraphikgengqlgomodelAggFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_aggregateDocs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.AggFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNAggFilter2githubcomgraphikDBgraphikgengqlgomodelAggFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_connectionsFrom_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ConnectFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNConnectFilter2githubcomgraphikDBgraphikgengqlgomodelConnectFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_connectionsTo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ConnectFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNConnectFilter2githubcomgraphikDBgraphikgengqlgomodelConnectFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_existsConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExistsFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNExistsFilter2githubcomgraphikDBgraphikgengqlgomodelExistsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_existsDoc_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ExistsFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNExistsFilter2githubcomgraphikDBgraphikgengqlgomodelExistsFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RefInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getDoc_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RefInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getSchema_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *emptypb.Empty
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hasConnection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RefInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hasDoc_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RefInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_me_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *emptypb.Empty
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_searchConnections_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Filter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_searchDocs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Filter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_traverseMe_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TraverseMeFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNTraverseMeFilter2githubcomgraphikDBgraphikgengqlgomodelTraverseMeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_traverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TraverseFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNTraverseFilter2githubcomgraphikDBgraphikgengqlgomodelTraverseFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_stream_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.StreamFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNStreamFilter2githubcomgraphikDBgraphikgengqlgomodelStreamFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AuthTarget_user(ctx context.Context, field graphql.CollectedField, obj *model.AuthTarget) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AuthTarget",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	fc.Result = res
	return ec.marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthTarget_target(ctx context.Context, field graphql.CollectedField, obj *model.AuthTarget) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AuthTarget",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Target, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthTarget_peer(ctx context.Context, field graphql.CollectedField, obj *model.AuthTarget) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AuthTarget",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Peer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AuthTarget_headers(ctx context.Context, field graphql.CollectedField, obj *model.AuthTarget) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "AuthTarget",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Authorizer_name(ctx context.Context, field graphql.CollectedField, obj *model.Authorizer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Authorizer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Authorizer_method(ctx context.Context, field graphql.CollectedField, obj *model.Authorizer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Authorizer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Method, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Authorizer_expression(ctx context.Context, field graphql.CollectedField, obj *model.Authorizer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Authorizer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Authorizer_target_requests(ctx context.Context, field graphql.CollectedField, obj *model.Authorizer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Authorizer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Authorizer_target_responses(ctx context.Context, field graphql.CollectedField, obj *model.Authorizer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Authorizer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetResponses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Authorizers_authorizers(ctx context.Context, field graphql.CollectedField, obj *model.Authorizers) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Authorizers",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Authorizers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Authorizer)
	fc.Result = res
	return ec.marshalOAuthorizer2githubcomgraphikDBgraphikgengqlgomodelAuthorizer(ctx, field.Selections, res)
}

func (ec *executionContext) _Connection_ref(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Ref)
	fc.Result = res
	return ec.marshalNRef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, field.Selections, res)
}

func (ec *executionContext) _Connection_attributes(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Attributes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Connection_directed(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Connection_from(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Ref)
	fc.Result = res
	return ec.marshalNRef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, field.Selections, res)
}

func (ec *executionContext) _Connection_to(ctx context.Context, field graphql.CollectedField, obj *model.Connection) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Connection",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Ref)
	fc.Result = res
	return ec.marshalNRef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, field.Selections, res)
}

func (ec *executionContext) _Connections_connections(ctx context.Context, field graphql.CollectedField, obj *model.Connections) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Connections",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Connections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Connection)
	fc.Result = res
	return ec.marshalOConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Connections_seek_next(ctx context.Context, field graphql.CollectedField, obj *model.Connections) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Connections",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeekNext, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_ref(ctx context.Context, field graphql.CollectedField, obj *model.Doc) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Doc",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Ref)
	fc.Result = res
	return ec.marshalNRef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, field.Selections, res)
}

func (ec *executionContext) _Doc_attributes(ctx context.Context, field graphql.CollectedField, obj *model.Doc) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Doc",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Attributes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Docs_docs(ctx context.Context, field graphql.CollectedField, obj *model.Docs) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Docs",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Docs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Doc)
	fc.Result = res
	return ec.marshalODoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Docs_seek_next(ctx context.Context, field graphql.CollectedField, obj *model.Docs) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Docs",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeekNext, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Index_name(ctx context.Context, field graphql.CollectedField, obj *model.Index) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Index",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Index_gtype(ctx context.Context, field graphql.CollectedField, obj *model.Index) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Index",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gtype, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Index_expression(ctx context.Context, field graphql.CollectedField, obj *model.Index) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Index",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Index_target_docs(ctx context.Context, field graphql.CollectedField, obj *model.Index) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Index",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetDocs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Index_target_connections(ctx context.Context, field graphql.CollectedField, obj *model.Index) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Index",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Indexes_indexes(ctx context.Context, field graphql.CollectedField, obj *model.Indexes) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Indexes",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indexes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Index)
	fc.Result = res
	return ec.marshalOIndex2githubcomgraphikDBgraphikgengqlgomodelIndex(ctx, field.Selections, res)
}

func (ec *executionContext) _Message_channel(ctx context.Context, field graphql.CollectedField, obj *model.Message) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Message",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Message_data(ctx context.Context, field graphql.CollectedField, obj *model.Message) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Message",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Message_user(ctx context.Context, field graphql.CollectedField, obj *model.Message) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Message",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Ref)
	fc.Result = res
	return ec.marshalNRef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, field.Selections, res)
}

func (ec *executionContext) _Message_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.Message) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Message",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Message_method(ctx context.Context, field graphql.CollectedField, obj *model.Message) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Message",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Method, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createDoc(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createDoc_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDoc(rctx, args["input"].(model.DocConstructor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	fc.Result = res
	return ec.marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createDocs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createDocs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDocs(rctx, args["input"].(model.DocConstructors))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Docs)
	fc.Result = res
	return ec.marshalNDocs2githubcomgraphikDBgraphikgengqlgomodelDocs(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_editDoc(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_editDoc_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditDoc(rctx, args["input"].(model.Edit))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	fc.Result = res
	return ec.marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_editDocs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_editDocs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditDocs(rctx, args["input"].(model.EditFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Docs)
	fc.Result = res
	return ec.marshalNDocs2githubcomgraphikDBgraphikgengqlgomodelDocs(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delDoc(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delDoc_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelDoc(rctx, args["input"].(model.RefInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delDocs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delDocs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelDocs(rctx, args["input"].(model.Filter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateConnection(rctx, args["input"].(model.ConnectionConstructor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connection)
	fc.Result = res
	return ec.marshalNConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createConnections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createConnections_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateConnections(rctx, args["input"].(model.ConnectionConstructors))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connections)
	fc.Result = res
	return ec.marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_editConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_editConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditConnection(rctx, args["input"].(model.Edit))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connection)
	fc.Result = res
	return ec.marshalNConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_editConnections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_editConnections_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditConnections(rctx, args["input"].(model.EditFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connections)
	fc.Result = res
	return ec.marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelConnection(rctx, args["input"].(model.RefInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_delConnections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_delConnections_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DelConnections(rctx, args["input"].(model.Filter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_broadcast(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_broadcast_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Broadcast(rctx, args["input"].(model.OutboundMessage))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_setIndexes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_setIndexes_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetIndexes(rctx, args["input"].(model.IndexesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_setAuthorizers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_setAuthorizers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetAuthorizers(rctx, args["input"].(model.AuthorizersInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_setTypeValidators(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_setTypeValidators_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTypeValidators(rctx, args["input"].(model.TypeValidatorsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_setTriggers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_setTriggers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTriggers(rctx, args["input"].(model.TriggersInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*emptypb.Empty)
	fc.Result = res
	return ec.marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_searchAndConnect(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_searchAndConnect_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SearchAndConnect(rctx, args["input"].(model.SearchConnectFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connections)
	fc.Result = res
	return ec.marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_searchAndConnectMe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_searchAndConnectMe_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SearchAndConnectMe(rctx, args["input"].(model.SearchConnectMeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connections)
	fc.Result = res
	return ec.marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx, field.Selections, res)
}

func (ec *executionContext) _Peer_node_id(ctx context.Context, field graphql.CollectedField, obj *model.Peer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NodeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Peer_addr(ctx context.Context, field graphql.CollectedField, obj *model.Peer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Peer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Addr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getSchema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getSchema_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetSchema(rctx, args["where"].(*emptypb.Empty))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Schema)
	fc.Result = res
	return ec.marshalNSchema2githubcomgraphikDBgraphikgengqlgomodelSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_me_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx, args["where"].(*emptypb.Empty))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	fc.Result = res
	return ec.marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getDoc(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getDoc_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetDoc(rctx, args["where"].(model.RefInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	fc.Result = res
	return ec.marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_searchDocs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_searchDocs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchDocs(rctx, args["where"].(model.Filter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Docs)
	fc.Result = res
	return ec.marshalNDocs2githubcomgraphikDBgraphikgengqlgomodelDocs(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_traverse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_traverse_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Traverse(rctx, args["where"].(model.TraverseFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Traversals)
	fc.Result = res
	return ec.marshalNTraversals2githubcomgraphikDBgraphikgengqlgomodelTraversals(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_traverseMe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_traverseMe_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TraverseMe(rctx, args["where"].(model.TraverseMeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Traversals)
	fc.Result = res
	return ec.marshalNTraversals2githubcomgraphikDBgraphikgengqlgomodelTraversals(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_getConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_getConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetConnection(rctx, args["where"].(model.RefInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connection)
	fc.Result = res
	return ec.marshalNConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_existsDoc(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_existsDoc_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ExistsDoc(rctx, args["where"].(model.ExistsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_existsConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_existsConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ExistsConnection(rctx, args["where"].(model.ExistsFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_hasDoc(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_hasDoc_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HasDoc(rctx, args["where"].(model.RefInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_hasConnection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_hasConnection_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HasConnection(rctx, args["where"].(model.RefInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_searchConnections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_searchConnections_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchConnections(rctx, args["where"].(model.Filter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connections)
	fc.Result = res
	return ec.marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_connectionsFrom(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_connectionsFrom_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionsFrom(rctx, args["where"].(model.ConnectFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connections)
	fc.Result = res
	return ec.marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_connectionsTo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_connectionsTo_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectionsTo(rctx, args["where"].(model.ConnectFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Connections)
	fc.Result = res
	return ec.marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_aggregateDocs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_aggregateDocs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AggregateDocs(rctx, args["where"].(model.AggFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_aggregateConnections(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_aggregateConnections_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AggregateConnections(rctx, args["where"].(model.AggFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RaftState_leader(ctx context.Context, field graphql.CollectedField, obj *model.RaftState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RaftState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Leader, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _RaftState_membership(ctx context.Context, field graphql.CollectedField, obj *model.RaftState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RaftState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Membership, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Membership)
	fc.Result = res
	return ec.marshalNMembership2githubcomgraphikDBgraphikgengqlgomodelMembership(ctx, field.Selections, res)
}

func (ec *executionContext) _RaftState_peers(ctx context.Context, field graphql.CollectedField, obj *model.RaftState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RaftState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Peers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Peer)
	fc.Result = res
	return ec.marshalOPeer2githubcomgraphikDBgraphikgengqlgomodelPeer(ctx, field.Selections, res)
}

func (ec *executionContext) _RaftState_stats(ctx context.Context, field graphql.CollectedField, obj *model.RaftState) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "RaftState",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) _Ref_gtype(ctx context.Context, field graphql.CollectedField, obj *model.Ref) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Ref",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gtype, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Ref_gid(ctx context.Context, field graphql.CollectedField, obj *model.Ref) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Ref",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Refs_refs(ctx context.Context, field graphql.CollectedField, obj *model.Refs) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Refs",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Ref)
	fc.Result = res
	return ec.marshalORef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, field.Selections, res)
}

func (ec *executionContext) _Schema_connection_types(ctx context.Context, field graphql.CollectedField, obj *model.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectionTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Schema_doc_types(ctx context.Context, field graphql.CollectedField, obj *model.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Schema_authorizers(ctx context.Context, field graphql.CollectedField, obj *model.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Authorizers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Authorizers)
	fc.Result = res
	return ec.marshalOAuthorizers2githubcomgraphikDBgraphikgengqlgomodelAuthorizers(ctx, field.Selections, res)
}

func (ec *executionContext) _Schema_validators(ctx context.Context, field graphql.CollectedField, obj *model.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validators, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TypeValidators)
	fc.Result = res
	return ec.marshalOTypeValidators2githubcomgraphikDBgraphikgengqlgomodelTypeValidators(ctx, field.Selections, res)
}

func (ec *executionContext) _Schema_indexes(ctx context.Context, field graphql.CollectedField, obj *model.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Indexes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Indexes)
	fc.Result = res
	return ec.marshalOIndexes2githubcomgraphikDBgraphikgengqlgomodelIndexes(ctx, field.Selections, res)
}

func (ec *executionContext) _Schema_triggers(ctx context.Context, field graphql.CollectedField, obj *model.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Triggers)
	fc.Result = res
	return ec.marshalOTriggers2githubcomgraphikDBgraphikgengqlgomodelTriggers(ctx, field.Selections, res)
}

func (ec *executionContext) _Subscription_stream(ctx context.Context, field graphql.CollectedField) (ret func() graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Subscription_stream_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Stream(rctx, args["where"].(model.StreamFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func() graphql.Marshaler {
		res, ok := <-resTmp.(<-chan *model.Message)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNMessage2githubcomgraphikDBgraphikgengqlgomodelMessage(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) _Traversal_doc(ctx context.Context, field graphql.CollectedField, obj *model.Traversal) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Traversal",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Doc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Doc)
	fc.Result = res
	return ec.marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, field.Selections, res)
}

func (ec *executionContext) _Traversal_traversal_path(ctx context.Context, field graphql.CollectedField, obj *model.Traversal) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Traversal",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraversalPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Ref)
	fc.Result = res
	return ec.marshalORef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, field.Selections, res)
}

func (ec *executionContext) _Traversal_depth(ctx context.Context, field graphql.CollectedField, obj *model.Traversal) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Traversal",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Depth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Traversal_hops(ctx context.Context, field graphql.CollectedField, obj *model.Traversal) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Traversal",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Traversals_traversals(ctx context.Context, field graphql.CollectedField, obj *model.Traversals) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Traversals",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Traversals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Traversal)
	fc.Result = res
	return ec.marshalOTraversal2githubcomgraphikDBgraphikgengqlgomodelTraversal(ctx, field.Selections, res)
}

func (ec *executionContext) _Trigger_name(ctx context.Context, field graphql.CollectedField, obj *model.Trigger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Trigger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trigger_gtype(ctx context.Context, field graphql.CollectedField, obj *model.Trigger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Trigger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gtype, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trigger_expression(ctx context.Context, field graphql.CollectedField, obj *model.Trigger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Trigger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trigger_trigger(ctx context.Context, field graphql.CollectedField, obj *model.Trigger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Trigger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trigger_target_docs(ctx context.Context, field graphql.CollectedField, obj *model.Trigger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Trigger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetDocs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Trigger_target_connections(ctx context.Context, field graphql.CollectedField, obj *model.Trigger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Trigger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Triggers_triggers(ctx context.Context, field graphql.CollectedField, obj *model.Triggers) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Triggers",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Trigger)
	fc.Result = res
	return ec.marshalOTrigger2githubcomgraphikDBgraphikgengqlgomodelTrigger(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeValidator_name(ctx context.Context, field graphql.CollectedField, obj *model.TypeValidator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeValidator",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeValidator_gtype(ctx context.Context, field graphql.CollectedField, obj *model.TypeValidator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeValidator",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gtype, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeValidator_expression(ctx context.Context, field graphql.CollectedField, obj *model.TypeValidator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeValidator",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeValidator_target_docs(ctx context.Context, field graphql.CollectedField, obj *model.TypeValidator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeValidator",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetDocs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeValidator_target_connections(ctx context.Context, field graphql.CollectedField, obj *model.TypeValidator) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeValidator",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetConnections, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _TypeValidators_validators(ctx context.Context, field graphql.CollectedField, obj *model.TypeValidators) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "TypeValidators",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validators, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TypeValidator)
	fc.Result = res
	return ec.marshalOTypeValidator2githubcomgraphikDBgraphikgengqlgomodelTypeValidator(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAggFilter(ctx context.Context, obj interface{}) (model.AggFilter, error) {
	var it model.AggFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			it.Filter, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "aggregate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aggregate"))
			it.Aggregate, err = ec.unmarshalNAggregate2githubcomgraphikDBgraphikgengqlgomodelAggregate(ctx, v)
			if err != nil {
				return it, err
			}
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			it.Field, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthorizerInput(ctx context.Context, obj interface{}) (model.AuthorizerInput, error) {
	var it model.AuthorizerInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "method":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			it.Method, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_requests":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_requests"))
			it.TargetRequests, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_responses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_responses"))
			it.TargetResponses, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthorizersInput(ctx context.Context, obj interface{}) (model.AuthorizersInput, error) {
	var it model.AuthorizersInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "authorizers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizers"))
			it.Authorizers, err = ec.unmarshalOAuthorizerInput2githubcomgraphikDBgraphikgengqlgomodelAuthorizerInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConnectFilter(ctx context.Context, obj interface{}) (model.ConnectFilter, error) {
	var it model.ConnectFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "doc_ref":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("doc_ref"))
			it.DocRef, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			it.Sort, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "seek":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seek"))
			it.Seek, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "reverse":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse"))
			it.Reverse, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConnectionConstructor(ctx context.Context, obj interface{}) (model.ConnectionConstructor, error) {
	var it model.ConnectionConstructor
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "ref":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ref"))
			it.Ref, err = ec.unmarshalNRefConstructor2githubcomgraphikDBgraphikgengqlgomodelRefConstructor(ctx, v)
			if err != nil {
				return it, err
			}
		case "directed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("directed"))
			it.Directed, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			it.From, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "to":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
			it.To, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConnectionConstructors(ctx context.Context, obj interface{}) (model.ConnectionConstructors, error) {
	var it model.ConnectionConstructors
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "connections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connections"))
			it.Connections, err = ec.unmarshalNConnectionConstructor2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructor(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDocConstructor(ctx context.Context, obj interface{}) (model.DocConstructor, error) {
	var it model.DocConstructor
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "ref":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ref"))
			it.Ref, err = ec.unmarshalNRefConstructor2githubcomgraphikDBgraphikgengqlgomodelRefConstructor(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDocConstructors(ctx context.Context, obj interface{}) (model.DocConstructors, error) {
	var it model.DocConstructors
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "docs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("docs"))
			it.Docs, err = ec.unmarshalNDocConstructor2githubcomgraphikDBgraphikgengqlgomodelDocConstructor(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEdit(ctx context.Context, obj interface{}) (model.Edit, error) {
	var it model.Edit
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "ref":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ref"))
			it.Ref, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditFilter(ctx context.Context, obj interface{}) (model.EditFilter, error) {
	var it model.EditFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			it.Filter, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExistsFilter(ctx context.Context, obj interface{}) (model.ExistsFilter, error) {
	var it model.ExistsFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "seek":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seek"))
			it.Seek, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "reverse":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse"))
			it.Reverse, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "index":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("index"))
			it.Index, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExprFilter(ctx context.Context, obj interface{}) (model.ExprFilter, error) {
	var it model.ExprFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilter(ctx context.Context, obj interface{}) (model.Filter, error) {
	var it model.Filter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			it.Sort, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "seek":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seek"))
			it.Seek, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "reverse":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse"))
			it.Reverse, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "index":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("index"))
			it.Index, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIndexInput(ctx context.Context, obj interface{}) (model.IndexInput, error) {
	var it model.IndexInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_docs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_docs"))
			it.TargetDocs, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_connections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_connections"))
			it.TargetConnections, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIndexesInput(ctx context.Context, obj interface{}) (model.IndexesInput, error) {
	var it model.IndexesInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "indexes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexes"))
			it.Indexes, err = ec.unmarshalOIndexInput2githubcomgraphikDBgraphikgengqlgomodelIndexInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOutboundMessage(ctx context.Context, obj interface{}) (model.OutboundMessage, error) {
	var it model.OutboundMessage
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "channel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			it.Channel, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "data":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			it.Data, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPeerInput(ctx context.Context, obj interface{}) (model.PeerInput, error) {
	var it model.PeerInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "node_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("node_id"))
			it.NodeID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "addr":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addr"))
			it.Addr, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRefConstructor(ctx context.Context, obj interface{}) (model.RefConstructor, error) {
	var it model.RefConstructor
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gid"))
			it.Gid, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRefInput(ctx context.Context, obj interface{}) (model.RefInput, error) {
	var it model.RefInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gid":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gid"))
			it.Gid, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchConnectFilter(ctx context.Context, obj interface{}) (model.SearchConnectFilter, error) {
	var it model.SearchConnectFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			it.Filter, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "directed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("directed"))
			it.Directed, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			it.From, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchConnectMeFilter(ctx context.Context, obj interface{}) (model.SearchConnectMeFilter, error) {
	var it model.SearchConnectMeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "filter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
			it.Filter, err = ec.unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "attributes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			it.Attributes, err = ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "directed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("directed"))
			it.Directed, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStreamFilter(ctx context.Context, obj interface{}) (model.StreamFilter, error) {
	var it model.StreamFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "channel":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			it.Channel, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTraverseFilter(ctx context.Context, obj interface{}) (model.TraverseFilter, error) {
	var it model.TraverseFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "root":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("root"))
			it.Root, err = ec.unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "doc_expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("doc_expression"))
			it.DocExpression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "connection_expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connection_expression"))
			it.ConnectionExpression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			it.Sort, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "reverse":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse"))
			it.Reverse, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "algorithm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("algorithm"))
			it.Algorithm, err = ec.unmarshalOAlgorithm2githubcomgraphikDBgraphikgengqlgomodelAlgorithm(ctx, v)
			if err != nil {
				return it, err
			}
		case "max_depth":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_depth"))
			it.MaxDepth, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "max_hops":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_hops"))
			it.MaxHops, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTraverseMeFilter(ctx context.Context, obj interface{}) (model.TraverseMeFilter, error) {
	var it model.TraverseMeFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "doc_expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("doc_expression"))
			it.DocExpression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "connection_expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("connection_expression"))
			it.ConnectionExpression, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "sort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			it.Sort, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "reverse":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("reverse"))
			it.Reverse, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "algorithm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("algorithm"))
			it.Algorithm, err = ec.unmarshalOAlgorithm2githubcomgraphikDBgraphikgengqlgomodelAlgorithm(ctx, v)
			if err != nil {
				return it, err
			}
		case "max_depth":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_depth"))
			it.MaxDepth, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "max_hops":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_hops"))
			it.MaxHops, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerInput(ctx context.Context, obj interface{}) (model.TriggerInput, error) {
	var it model.TriggerInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "trigger":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger"))
			it.Trigger, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_docs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_docs"))
			it.TargetDocs, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_connections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_connections"))
			it.TargetConnections, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggersInput(ctx context.Context, obj interface{}) (model.TriggersInput, error) {
	var it model.TriggersInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "triggers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			it.Triggers, err = ec.unmarshalOTriggerInput2githubcomgraphikDBgraphikgengqlgomodelTriggerInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeValidatorInput(ctx context.Context, obj interface{}) (model.TypeValidatorInput, error) {
	var it model.TypeValidatorInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "gtype":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gtype"))
			it.Gtype, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			it.Expression, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_docs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_docs"))
			it.TargetDocs, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "target_connections":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target_connections"))
			it.TargetConnections, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTypeValidatorsInput(ctx context.Context, obj interface{}) (model.TypeValidatorsInput, error) {
	var it model.TypeValidatorsInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "validators":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validators"))
			it.Validators, err = ec.unmarshalOTypeValidatorInput2githubcomgraphikDBgraphikgengqlgomodelTypeValidatorInput(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var authTargetImplementors = []string{"AuthTarget"}

func (ec *executionContext) _AuthTarget(ctx context.Context, sel ast.SelectionSet, obj *model.AuthTarget) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authTargetImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthTarget")
		case "user":
			out.Values[i] = ec._AuthTarget_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target":
			out.Values[i] = ec._AuthTarget_target(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "peer":
			out.Values[i] = ec._AuthTarget_peer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "headers":
			out.Values[i] = ec._AuthTarget_headers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var authorizerImplementors = []string{"Authorizer"}

func (ec *executionContext) _Authorizer(ctx context.Context, sel ast.SelectionSet, obj *model.Authorizer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authorizerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Authorizer")
		case "name":
			out.Values[i] = ec._Authorizer_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "method":
			out.Values[i] = ec._Authorizer_method(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expression":
			out.Values[i] = ec._Authorizer_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_requests":
			out.Values[i] = ec._Authorizer_target_requests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_responses":
			out.Values[i] = ec._Authorizer_target_responses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var authorizersImplementors = []string{"Authorizers"}

func (ec *executionContext) _Authorizers(ctx context.Context, sel ast.SelectionSet, obj *model.Authorizers) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authorizersImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Authorizers")
		case "authorizers":
			out.Values[i] = ec._Authorizers_authorizers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var connectionImplementors = []string{"Connection"}

func (ec *executionContext) _Connection(ctx context.Context, sel ast.SelectionSet, obj *model.Connection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Connection")
		case "ref":
			out.Values[i] = ec._Connection_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attributes":
			out.Values[i] = ec._Connection_attributes(ctx, field, obj)
		case "directed":
			out.Values[i] = ec._Connection_directed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "from":
			out.Values[i] = ec._Connection_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "to":
			out.Values[i] = ec._Connection_to(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var connectionsImplementors = []string{"Connections"}

func (ec *executionContext) _Connections(ctx context.Context, sel ast.SelectionSet, obj *model.Connections) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectionsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Connections")
		case "connections":
			out.Values[i] = ec._Connections_connections(ctx, field, obj)
		case "seek_next":
			out.Values[i] = ec._Connections_seek_next(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var docImplementors = []string{"Doc"}

func (ec *executionContext) _Doc(ctx context.Context, sel ast.SelectionSet, obj *model.Doc) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, docImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Doc")
		case "ref":
			out.Values[i] = ec._Doc_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attributes":
			out.Values[i] = ec._Doc_attributes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var docsImplementors = []string{"Docs"}

func (ec *executionContext) _Docs(ctx context.Context, sel ast.SelectionSet, obj *model.Docs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, docsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Docs")
		case "docs":
			out.Values[i] = ec._Docs_docs(ctx, field, obj)
		case "seek_next":
			out.Values[i] = ec._Docs_seek_next(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var indexImplementors = []string{"Index"}

func (ec *executionContext) _Index(ctx context.Context, sel ast.SelectionSet, obj *model.Index) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, indexImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Index")
		case "name":
			out.Values[i] = ec._Index_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gtype":
			out.Values[i] = ec._Index_gtype(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expression":
			out.Values[i] = ec._Index_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_docs":
			out.Values[i] = ec._Index_target_docs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_connections":
			out.Values[i] = ec._Index_target_connections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var indexesImplementors = []string{"Indexes"}

func (ec *executionContext) _Indexes(ctx context.Context, sel ast.SelectionSet, obj *model.Indexes) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, indexesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Indexes")
		case "indexes":
			out.Values[i] = ec._Indexes_indexes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var messageImplementors = []string{"Message"}

func (ec *executionContext) _Message(ctx context.Context, sel ast.SelectionSet, obj *model.Message) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, messageImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Message")
		case "channel":
			out.Values[i] = ec._Message_channel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":
			out.Values[i] = ec._Message_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "user":
			out.Values[i] = ec._Message_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":
			out.Values[i] = ec._Message_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "method":
			out.Values[i] = ec._Message_method(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createDoc":
			out.Values[i] = ec._Mutation_createDoc(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDocs":
			out.Values[i] = ec._Mutation_createDocs(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "editDoc":
			out.Values[i] = ec._Mutation_editDoc(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "editDocs":
			out.Values[i] = ec._Mutation_editDocs(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delDoc":
			out.Values[i] = ec._Mutation_delDoc(ctx, field)
		case "delDocs":
			out.Values[i] = ec._Mutation_delDocs(ctx, field)
		case "createConnection":
			out.Values[i] = ec._Mutation_createConnection(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createConnections":
			out.Values[i] = ec._Mutation_createConnections(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "editConnection":
			out.Values[i] = ec._Mutation_editConnection(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "editConnections":
			out.Values[i] = ec._Mutation_editConnections(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "delConnection":
			out.Values[i] = ec._Mutation_delConnection(ctx, field)
		case "delConnections":
			out.Values[i] = ec._Mutation_delConnections(ctx, field)
		case "broadcast":
			out.Values[i] = ec._Mutation_broadcast(ctx, field)
		case "setIndexes":
			out.Values[i] = ec._Mutation_setIndexes(ctx, field)
		case "setAuthorizers":
			out.Values[i] = ec._Mutation_setAuthorizers(ctx, field)
		case "setTypeValidators":
			out.Values[i] = ec._Mutation_setTypeValidators(ctx, field)
		case "setTriggers":
			out.Values[i] = ec._Mutation_setTriggers(ctx, field)
		case "searchAndConnect":
			out.Values[i] = ec._Mutation_searchAndConnect(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "searchAndConnectMe":
			out.Values[i] = ec._Mutation_searchAndConnectMe(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var peerImplementors = []string{"Peer"}

func (ec *executionContext) _Peer(ctx context.Context, sel ast.SelectionSet, obj *model.Peer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, peerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Peer")
		case "node_id":
			out.Values[i] = ec._Peer_node_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addr":
			out.Values[i] = ec._Peer_addr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getSchema":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getSchema(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "me":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getDoc":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDoc(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "searchDocs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchDocs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "traverse":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_traverse(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "traverseMe":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_traverseMe(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "getConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getConnection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "existsDoc":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_existsDoc(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "existsConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_existsConnection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "hasDoc":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hasDoc(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "hasConnection":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hasConnection(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "searchConnections":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchConnections(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "connectionsFrom":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionsFrom(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "connectionsTo":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectionsTo(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "aggregateDocs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_aggregateDocs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "aggregateConnections":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_aggregateConnections(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var raftStateImplementors = []string{"RaftState"}

func (ec *executionContext) _RaftState(ctx context.Context, sel ast.SelectionSet, obj *model.RaftState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, raftStateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RaftState")
		case "leader":
			out.Values[i] = ec._RaftState_leader(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "membership":
			out.Values[i] = ec._RaftState_membership(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "peers":
			out.Values[i] = ec._RaftState_peers(ctx, field, obj)
		case "stats":
			out.Values[i] = ec._RaftState_stats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var refImplementors = []string{"Ref"}

func (ec *executionContext) _Ref(ctx context.Context, sel ast.SelectionSet, obj *model.Ref) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Ref")
		case "gtype":
			out.Values[i] = ec._Ref_gtype(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gid":
			out.Values[i] = ec._Ref_gid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var refsImplementors = []string{"Refs"}

func (ec *executionContext) _Refs(ctx context.Context, sel ast.SelectionSet, obj *model.Refs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Refs")
		case "refs":
			out.Values[i] = ec._Refs_refs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var schemaImplementors = []string{"Schema"}

func (ec *executionContext) _Schema(ctx context.Context, sel ast.SelectionSet, obj *model.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, schemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Schema")
		case "connection_types":
			out.Values[i] = ec._Schema_connection_types(ctx, field, obj)
		case "doc_types":
			out.Values[i] = ec._Schema_doc_types(ctx, field, obj)
		case "authorizers":
			out.Values[i] = ec._Schema_authorizers(ctx, field, obj)
		case "validators":
			out.Values[i] = ec._Schema_validators(ctx, field, obj)
		case "indexes":
			out.Values[i] = ec._Schema_indexes(ctx, field, obj)
		case "triggers":
			out.Values[i] = ec._Schema_triggers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func() graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "stream":
		return ec._Subscription_stream(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var traversalImplementors = []string{"Traversal"}

func (ec *executionContext) _Traversal(ctx context.Context, sel ast.SelectionSet, obj *model.Traversal) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, traversalImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Traversal")
		case "doc":
			out.Values[i] = ec._Traversal_doc(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "traversal_path":
			out.Values[i] = ec._Traversal_traversal_path(ctx, field, obj)
		case "depth":
			out.Values[i] = ec._Traversal_depth(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hops":
			out.Values[i] = ec._Traversal_hops(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var traversalsImplementors = []string{"Traversals"}

func (ec *executionContext) _Traversals(ctx context.Context, sel ast.SelectionSet, obj *model.Traversals) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, traversalsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Traversals")
		case "traversals":
			out.Values[i] = ec._Traversals_traversals(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var triggerImplementors = []string{"Trigger"}

func (ec *executionContext) _Trigger(ctx context.Context, sel ast.SelectionSet, obj *model.Trigger) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trigger")
		case "name":
			out.Values[i] = ec._Trigger_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gtype":
			out.Values[i] = ec._Trigger_gtype(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expression":
			out.Values[i] = ec._Trigger_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "trigger":
			out.Values[i] = ec._Trigger_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_docs":
			out.Values[i] = ec._Trigger_target_docs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_connections":
			out.Values[i] = ec._Trigger_target_connections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var triggersImplementors = []string{"Triggers"}

func (ec *executionContext) _Triggers(ctx context.Context, sel ast.SelectionSet, obj *model.Triggers) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggersImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Triggers")
		case "triggers":
			out.Values[i] = ec._Triggers_triggers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeValidatorImplementors = []string{"TypeValidator"}

func (ec *executionContext) _TypeValidator(ctx context.Context, sel ast.SelectionSet, obj *model.TypeValidator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeValidatorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeValidator")
		case "name":
			out.Values[i] = ec._TypeValidator_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gtype":
			out.Values[i] = ec._TypeValidator_gtype(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "expression":
			out.Values[i] = ec._TypeValidator_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_docs":
			out.Values[i] = ec._TypeValidator_target_docs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "target_connections":
			out.Values[i] = ec._TypeValidator_target_connections(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var typeValidatorsImplementors = []string{"TypeValidators"}

func (ec *executionContext) _TypeValidators(ctx context.Context, sel ast.SelectionSet, obj *model.TypeValidators) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, typeValidatorsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeValidators")
		case "validators":
			out.Values[i] = ec._TypeValidators_validators(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAggFilter2githubcomgraphikDBgraphikgengqlgomodelAggFilter(ctx context.Context, v interface{}) (model.AggFilter, error) {
	res, err := ec.unmarshalInputAggFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAggregate2githubcomgraphikDBgraphikgengqlgomodelAggregate(ctx context.Context, v interface{}) (model.Aggregate, error) {
	var res model.Aggregate
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAggregate2githubcomgraphikDBgraphikgengqlgomodelAggregate(ctx context.Context, sel ast.SelectionSet, v model.Aggregate) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAuthorizer2githubcomgraphikDBgraphikgengqlgomodelAuthorizer(ctx context.Context, sel ast.SelectionSet, v *model.Authorizer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Authorizer(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthorizerInput2githubcomgraphikDBgraphikgengqlgomodelAuthorizerInput(ctx context.Context, v interface{}) (*model.AuthorizerInput, error) {
	res, err := ec.unmarshalInputAuthorizerInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthorizersInput2githubcomgraphikDBgraphikgengqlgomodelAuthorizersInput(ctx context.Context, v interface{}) (model.AuthorizersInput, error) {
	res, err := ec.unmarshalInputAuthorizersInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNConnectFilter2githubcomgraphikDBgraphikgengqlgomodelConnectFilter(ctx context.Context, v interface{}) (model.ConnectFilter, error) {
	res, err := ec.unmarshalInputConnectFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx context.Context, sel ast.SelectionSet, v model.Connection) graphql.Marshaler {
	return ec._Connection(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx context.Context, sel ast.SelectionSet, v *model.Connection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Connection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConnectionConstructor2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructor(ctx context.Context, v interface{}) (model.ConnectionConstructor, error) {
	res, err := ec.unmarshalInputConnectionConstructor(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNConnectionConstructor2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructor(ctx context.Context, v interface{}) ([]*model.ConnectionConstructor, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.ConnectionConstructor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNConnectionConstructor2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNConnectionConstructor2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructor(ctx context.Context, v interface{}) (*model.ConnectionConstructor, error) {
	res, err := ec.unmarshalInputConnectionConstructor(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNConnectionConstructors2githubcomgraphikDBgraphikgengqlgomodelConnectionConstructors(ctx context.Context, v interface{}) (model.ConnectionConstructors, error) {
	res, err := ec.unmarshalInputConnectionConstructors(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx context.Context, sel ast.SelectionSet, v model.Connections) graphql.Marshaler {
	return ec._Connections(ctx, sel, &v)
}

func (ec *executionContext) marshalNConnections2githubcomgraphikDBgraphikgengqlgomodelConnections(ctx context.Context, sel ast.SelectionSet, v *model.Connections) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Connections(ctx, sel, v)
}

func (ec *executionContext) marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx context.Context, sel ast.SelectionSet, v model.Doc) graphql.Marshaler {
	return ec._Doc(ctx, sel, &v)
}

func (ec *executionContext) marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx context.Context, sel ast.SelectionSet, v *model.Doc) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Doc(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDocConstructor2githubcomgraphikDBgraphikgengqlgomodelDocConstructor(ctx context.Context, v interface{}) (model.DocConstructor, error) {
	res, err := ec.unmarshalInputDocConstructor(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDocConstructor2githubcomgraphikDBgraphikgengqlgomodelDocConstructor(ctx context.Context, v interface{}) ([]*model.DocConstructor, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.DocConstructor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDocConstructor2githubcomgraphikDBgraphikgengqlgomodelDocConstructor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNDocConstructor2githubcomgraphikDBgraphikgengqlgomodelDocConstructor(ctx context.Context, v interface{}) (*model.DocConstructor, error) {
	res, err := ec.unmarshalInputDocConstructor(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDocConstructors2githubcomgraphikDBgraphikgengqlgomodelDocConstructors(ctx context.Context, v interface{}) (model.DocConstructors, error) {
	res, err := ec.unmarshalInputDocConstructors(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDocs2githubcomgraphikDBgraphikgengqlgomodelDocs(ctx context.Context, sel ast.SelectionSet, v model.Docs) graphql.Marshaler {
	return ec._Docs(ctx, sel, &v)
}

func (ec *executionContext) marshalNDocs2githubcomgraphikDBgraphikgengqlgomodelDocs(ctx context.Context, sel ast.SelectionSet, v *model.Docs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Docs(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEdit2githubcomgraphikDBgraphikgengqlgomodelEdit(ctx context.Context, v interface{}) (model.Edit, error) {
	res, err := ec.unmarshalInputEdit(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEditFilter2githubcomgraphikDBgraphikgengqlgomodelEditFilter(ctx context.Context, v interface{}) (model.EditFilter, error) {
	res, err := ec.unmarshalInputEditFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNExistsFilter2githubcomgraphikDBgraphikgengqlgomodelExistsFilter(ctx context.Context, v interface{}) (model.ExistsFilter, error) {
	res, err := ec.unmarshalInputExistsFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx context.Context, v interface{}) (model.Filter, error) {
	res, err := ec.unmarshalInputFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFilter2githubcomgraphikDBgraphikgengqlgomodelFilter(ctx context.Context, v interface{}) (*model.Filter, error) {
	res, err := ec.unmarshalInputFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNIndex2githubcomgraphikDBgraphikgengqlgomodelIndex(ctx context.Context, sel ast.SelectionSet, v *model.Index) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Index(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIndexInput2githubcomgraphikDBgraphikgengqlgomodelIndexInput(ctx context.Context, v interface{}) (*model.IndexInput, error) {
	res, err := ec.unmarshalInputIndexInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNIndexesInput2githubcomgraphikDBgraphikgengqlgomodelIndexesInput(ctx context.Context, v interface{}) (model.IndexesInput, error) {
	res, err := ec.unmarshalInputIndexesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMembership2githubcomgraphikDBgraphikgengqlgomodelMembership(ctx context.Context, v interface{}) (model.Membership, error) {
	var res model.Membership
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMembership2githubcomgraphikDBgraphikgengqlgomodelMembership(ctx context.Context, sel ast.SelectionSet, v model.Membership) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMessage2githubcomgraphikDBgraphikgengqlgomodelMessage(ctx context.Context, sel ast.SelectionSet, v model.Message) graphql.Marshaler {
	return ec._Message(ctx, sel, &v)
}

func (ec *executionContext) marshalNMessage2githubcomgraphikDBgraphikgengqlgomodelMessage(ctx context.Context, sel ast.SelectionSet, v *model.Message) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Message(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOutboundMessage2githubcomgraphikDBgraphikgengqlgomodelOutboundMessage(ctx context.Context, v interface{}) (model.OutboundMessage, error) {
	res, err := ec.unmarshalInputOutboundMessage(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPeer2githubcomgraphikDBgraphikgengqlgomodelPeer(ctx context.Context, sel ast.SelectionSet, v *model.Peer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Peer(ctx, sel, v)
}

func (ec *executionContext) marshalNRef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx context.Context, sel ast.SelectionSet, v *model.Ref) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Ref(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRefConstructor2githubcomgraphikDBgraphikgengqlgomodelRefConstructor(ctx context.Context, v interface{}) (*model.RefConstructor, error) {
	res, err := ec.unmarshalInputRefConstructor(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx context.Context, v interface{}) (model.RefInput, error) {
	res, err := ec.unmarshalInputRefInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRefInput2githubcomgraphikDBgraphikgengqlgomodelRefInput(ctx context.Context, v interface{}) (*model.RefInput, error) {
	res, err := ec.unmarshalInputRefInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSchema2githubcomgraphikDBgraphikgengqlgomodelSchema(ctx context.Context, sel ast.SelectionSet, v model.Schema) graphql.Marshaler {
	return ec._Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalNSchema2githubcomgraphikDBgraphikgengqlgomodelSchema(ctx context.Context, sel ast.SelectionSet, v *model.Schema) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Schema(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSearchConnectFilter2githubcomgraphikDBgraphikgengqlgomodelSearchConnectFilter(ctx context.Context, v interface{}) (model.SearchConnectFilter, error) {
	res, err := ec.unmarshalInputSearchConnectFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSearchConnectMeFilter2githubcomgraphikDBgraphikgengqlgomodelSearchConnectMeFilter(ctx context.Context, v interface{}) (model.SearchConnectMeFilter, error) {
	res, err := ec.unmarshalInputSearchConnectMeFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNStreamFilter2githubcomgraphikDBgraphikgengqlgomodelStreamFilter(ctx context.Context, v interface{}) (model.StreamFilter, error) {
	res, err := ec.unmarshalInputStreamFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNTraversal2githubcomgraphikDBgraphikgengqlgomodelTraversal(ctx context.Context, sel ast.SelectionSet, v *model.Traversal) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Traversal(ctx, sel, v)
}

func (ec *executionContext) marshalNTraversals2githubcomgraphikDBgraphikgengqlgomodelTraversals(ctx context.Context, sel ast.SelectionSet, v model.Traversals) graphql.Marshaler {
	return ec._Traversals(ctx, sel, &v)
}

func (ec *executionContext) marshalNTraversals2githubcomgraphikDBgraphikgengqlgomodelTraversals(ctx context.Context, sel ast.SelectionSet, v *model.Traversals) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Traversals(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTraverseFilter2githubcomgraphikDBgraphikgengqlgomodelTraverseFilter(ctx context.Context, v interface{}) (model.TraverseFilter, error) {
	res, err := ec.unmarshalInputTraverseFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTraverseMeFilter2githubcomgraphikDBgraphikgengqlgomodelTraverseMeFilter(ctx context.Context, v interface{}) (model.TraverseMeFilter, error) {
	res, err := ec.unmarshalInputTraverseMeFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTrigger2githubcomgraphikDBgraphikgengqlgomodelTrigger(ctx context.Context, sel ast.SelectionSet, v *model.Trigger) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Trigger(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTriggerInput2githubcomgraphikDBgraphikgengqlgomodelTriggerInput(ctx context.Context, v interface{}) (*model.TriggerInput, error) {
	res, err := ec.unmarshalInputTriggerInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTriggersInput2githubcomgraphikDBgraphikgengqlgomodelTriggersInput(ctx context.Context, v interface{}) (model.TriggersInput, error) {
	res, err := ec.unmarshalInputTriggersInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTypeValidator2githubcomgraphikDBgraphikgengqlgomodelTypeValidator(ctx context.Context, sel ast.SelectionSet, v *model.TypeValidator) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TypeValidator(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTypeValidatorInput2githubcomgraphikDBgraphikgengqlgomodelTypeValidatorInput(ctx context.Context, v interface{}) (*model.TypeValidatorInput, error) {
	res, err := ec.unmarshalInputTypeValidatorInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTypeValidatorsInput2githubcomgraphikDBgraphikgengqlgomodelTypeValidatorsInput(ctx context.Context, v interface{}) (model.TypeValidatorsInput, error) {
	res, err := ec.unmarshalInputTypeValidatorsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAlgorithm2githubcomgraphikDBgraphikgengqlgomodelAlgorithm(ctx context.Context, v interface{}) (*model.Algorithm, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Algorithm)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlgorithm2githubcomgraphikDBgraphikgengqlgomodelAlgorithm(ctx context.Context, sel ast.SelectionSet, v *model.Algorithm) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAuthorizer2githubcomgraphikDBgraphikgengqlgomodelAuthorizer(ctx context.Context, sel ast.SelectionSet, v []*model.Authorizer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAuthorizer2githubcomgraphikDBgraphikgengqlgomodelAuthorizer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAuthorizerInput2githubcomgraphikDBgraphikgengqlgomodelAuthorizerInput(ctx context.Context, v interface{}) ([]*model.AuthorizerInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.AuthorizerInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAuthorizerInput2githubcomgraphikDBgraphikgengqlgomodelAuthorizerInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAuthorizers2githubcomgraphikDBgraphikgengqlgomodelAuthorizers(ctx context.Context, sel ast.SelectionSet, v *model.Authorizers) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Authorizers(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) marshalOConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx context.Context, sel ast.SelectionSet, v []*model.Connection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConnection2githubcomgraphikDBgraphikgengqlgomodelConnection(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalODoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx context.Context, sel ast.SelectionSet, v []*model.Doc) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDoc2githubcomgraphikDBgraphikgengqlgomodelDoc(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx context.Context, v interface{}) (*emptypb.Empty, error) {
	if v == nil {
		return nil, nil
	}
	res, err := scalars.UnmarshalEmptyScalar(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEmpty2googlegolangorgprotobuftypesknownemptypbEmpty(ctx context.Context, sel ast.SelectionSet, v *emptypb.Empty) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return scalars.MarshalEmptyScalar(v)
}

func (ec *executionContext) marshalOIndex2githubcomgraphikDBgraphikgengqlgomodelIndex(ctx context.Context, sel ast.SelectionSet, v []*model.Index) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIndex2githubcomgraphikDBgraphikgengqlgomodelIndex(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOIndexInput2githubcomgraphikDBgraphikgengqlgomodelIndexInput(ctx context.Context, v interface{}) ([]*model.IndexInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.IndexInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNIndexInput2githubcomgraphikDBgraphikgengqlgomodelIndexInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOIndexes2githubcomgraphikDBgraphikgengqlgomodelIndexes(ctx context.Context, sel ast.SelectionSet, v *model.Indexes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Indexes(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalMap(v)
}

func (ec *executionContext) marshalOPeer2githubcomgraphikDBgraphikgengqlgomodelPeer(ctx context.Context, sel ast.SelectionSet, v []*model.Peer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPeer2githubcomgraphikDBgraphikgengqlgomodelPeer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalORef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx context.Context, sel ast.SelectionSet, v []*model.Ref) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRef2githubcomgraphikDBgraphikgengqlgomodelRef(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) marshalOTraversal2githubcomgraphikDBgraphikgengqlgomodelTraversal(ctx context.Context, sel ast.SelectionSet, v []*model.Traversal) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTraversal2githubcomgraphikDBgraphikgengqlgomodelTraversal(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTrigger2githubcomgraphikDBgraphikgengqlgomodelTrigger(ctx context.Context, sel ast.SelectionSet, v []*model.Trigger) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrigger2githubcomgraphikDBgraphikgengqlgomodelTrigger(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOTriggerInput2githubcomgraphikDBgraphikgengqlgomodelTriggerInput(ctx context.Context, v interface{}) ([]*model.TriggerInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.TriggerInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTriggerInput2githubcomgraphikDBgraphikgengqlgomodelTriggerInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTriggers2githubcomgraphikDBgraphikgengqlgomodelTriggers(ctx context.Context, sel ast.SelectionSet, v *model.Triggers) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Triggers(ctx, sel, v)
}

func (ec *executionContext) marshalOTypeValidator2githubcomgraphikDBgraphikgengqlgomodelTypeValidator(ctx context.Context, sel ast.SelectionSet, v []*model.TypeValidator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTypeValidator2githubcomgraphikDBgraphikgengqlgomodelTypeValidator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOTypeValidatorInput2githubcomgraphikDBgraphikgengqlgomodelTypeValidatorInput(ctx context.Context, v interface{}) ([]*model.TypeValidatorInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*model.TypeValidatorInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTypeValidatorInput2githubcomgraphikDBgraphikgengqlgomodelTypeValidatorInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTypeValidators2githubcomgraphikDBgraphikgengqlgomodelTypeValidators(ctx context.Context, sel ast.SelectionSet, v *model.TypeValidators) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TypeValidators(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
